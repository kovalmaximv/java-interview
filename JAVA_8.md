# JAVA 8
### Что появилось в Java 8
+ Методы интерфейсов по умолчанию;
+ Lambda
+ Stream API для работы с коллекциями;
+ Новое API для работы с датами и временем; LocalDateTime etc
+ Optional

### Что такое «лямбда»?
**Лямбда** представляет собой набор инструкций, которые можно выделить в отдельную переменную и затем многократно 
вызвать в различных местах программы.

Основу лямбда-выражения составляет лямбда-оператор, который представляет стрелку ->. Этот оператор разделяет 
лямбда-выражение на две части: левая часть содержит список параметров выражения, а правая, собственно, представляет 
тело лямбда-выражения, где выполняются все действия.

Лямбда-выражение не выполняется само по себе, а образует реализацию метода, определенного в функциональном интерфейсе. 
При этом важно, что функциональный интерфейс должен содержать только один единственный метод без реализации.

По факту лямбда-выражения являются в некотором роде сокращенной формой внутренних анонимных классов, которые ранее
применялись в Java.

### К каким переменным есть доступ у лямбда-выражений?
Доступ к переменным внешней области действия из лямбда-выражения очень схож к доступу из анонимных объектов. 
Можно ссылаться на:
+ неизменяемые локальные переменные;
+ поля класса;
+ статические переменные.

### Что такое «ссылка на метод»?
Если существующий в классе метод уже делает все, что необходимо, то можно воспользоваться механизмом method reference 
(ссылка на метод) для непосредственной передачи этого метода. Такая ссылка передается в виде:
+ `имя_класса::имя_статического_метода` для статического метода;
+ `объект_класса::имя_метода` для метода экземпляра;
+ `название_класса::new` для конструктора.

### Что такое «функциональные интерфейсы»?
Функциональный интерфейс - это интерфейс, который определяет только один абстрактный метод.

Чтобы точно определить интерфейс как функциональный, добавлена аннотация @FunctionalInterface, работающая по принципу 
@Override. Она обозначит замысел и не даст определить второй абстрактный метод в интерфейсе.

шпаргалка по функиоальным интерфейсам Java:   
Supplier       ()    -> x  
Consumer       x     -> ()  
BiConsumer     x, y  -> ()  
Callable       ()    -> x throws ex  
Runnable       ()    -> ()  
Function       x     -> y  
BiFunction     x,y   -> z  
Predicate      x     -> boolean  
UnaryOperator  x1    -> x2  
BinaryOperator x1,x2 -> x3  

### Для чего нужны функциональные интерфейсы Function<T,R>, DoubleFunction<R>, IntFunction<R> и LongFunction<R>?
Function<T, R> - интерфейс, с помощью которого реализуется функция, получающая на вход экземпляр класса T и 
возвращающая на выходе экземпляр класса R.

DoubleFunction<R> - функция, получающая на вход Double и возвращающая на выходе экземпляр класса R;

BiFunction<T,U,R> представляет собой операцию, которая принимает два аргумента классов T и U и 
возвращающая результат класса R.

### Для чего нужны функциональные интерфейсы UnaryOperator<T>?
UnaryOperator<T> (унарный оператор) принимает в качестве параметра объект типа T, выполняет над ними операции и 
возвращает результат операций в виде объекта типа T.

### Для чего нужны функциональные интерфейсы BinaryOperator<T>?
BinaryOperator<T> (бинарный оператор) - интерфейс, с помощью которого реализуется функция, получающая на вход два 
экземпляра класса T и возвращающая на выходе экземпляр класса T.

### Для чего нужны функциональные интерфейсы Predicate<T>?
Predicate<T> (предикат) - интерфейс, с помощью которого реализуется функция, получающая на вход экземпляр класса 
T и возвращающая на выходе значение типа boolean.

### Для чего нужны функциональные интерфейсы Consumer<T>?
Consumer<T> (потребитель) - интерфейс, с помощью которого реализуется функция, которая получает на вход экземпляр 
класса T, производит с ним некоторое действие и ничего не возвращает.

BiConsumer<T,U> представляет собой операцию, которая принимает два аргумента классов T и U производит с ними 
некоторое действие и ничего не возвращает.

### Для чего нужны функциональные интерфейсы Supplier<T>?
Supplier<T> (поставщик) - интерфейс, с помощью которого реализуется функция, ничего не принимающая на вход, но 
возвращающая на выход результат класса T;

### Что такое default методы интрефейса?
Java 8 позволяет добавлять неабстрактные реализации методов в интерфейс, используя ключевое слово `default`

### Что такое static метод интерфейса?
Статические методы интерфейса похожи на методы по умолчанию, за исключением того, что для них отсутствует возможность 
переопределения в классах, реализующих интерфейс.

### Optional
Опциональное значение Optional — это контейнер для объекта, который может содержать или не содержать значение null. 
Такая обёртка является удобным средством предотвращения NullPointerException, т.к. имеет некоторые функции высшего 
порядка, избавляющие от добавления повторяющихся if null/notNull проверок.

### Что такое Stream?
Интерфейс java.util.Stream представляет собой конвейер вычислений над коллекциями.

Операции над стримами бывают или промежуточными (intermediate) или конечными (terminal). Конечные операции возвращают 
результат определенного типа, а промежуточные операции возвращают тот же стрим. Таким образом вы можете строить 
цепочки из несколько операций над одним и тем же стримом.

У стрима может быть сколько угодно вызовов промежуточных операций и последним вызов конечной операции. При этом все 
промежуточные операции выполняются лениво и пока не будет вызвана конечная операция никаких действий на самом деле не 
происходит

Операции над стримами могут выполняться как последовательно, так и параллельно.

### Расскажите о параллельной обработке в Java 8.
Стримы могут быть последовательными и параллельными. Операции над последовательными стримами выполняются в одном потоке 
процессора, над параллельными — используя несколько потоков процессора. Параллельные стримы используют общий 
ForkJoinPool доступный через статический ForkJoinPool.commonPool() метод. Фактически применение параллельных стримов 
сводится к тому, что данные в стримах будут разделены на части, каждая часть обрабатывается на отдельном ядре 
процессора, и в конце эти части соединяются, и над ними выполняются конечные операции.

С помощью, методов parallel() и sequential() можно определять какие операции **могут быть** параллельными, а какие 
**только** последовательными. Так же из любого последовательного стрима можно сделать параллельный и наоборот.

### Что такое LocalDateTime?
LocalDateTime объединяет вместе LocaleDate и LocalTime, содержит дату и время без привязки к часовому поясу. Время 
хранится с точностью до наносекунды. Содержит множество удобных методов, таких как plusMinutes, plusHours, isAfter, 
toSecondOfDay и т.д.

### Что такое ZonedDateTime?
Класс с самым полным объемом информации о временном контексте. Включает временную зону, поэтому все операции с
временными сдвигами этот класс проводит с её учётом.