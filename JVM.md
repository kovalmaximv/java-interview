# JVM

### За что отвечает JVM
+ Загрузка, проверка и исполнение байт кода;
+ Предоставление среды выполнения для выполнения байт-кода;
+ Управление памятью и очисткой мусора (Garbage collection);

### Run-Time Data Areas
JVM выделяет множество областей данных во время выполнения, которые используются во время выполнения программы.

**The pc Register (PCR)**  
Для одного потока, существует один PCR, который создается при запуске потока. 
PCR хранит адрес выполняемой сейчас инструкции JVM.

**Java Virtual Machine Stacks**  
Каждый поток в JVM имеет собственный стек, созданный одновременно с потоком. Стек в JVM хранит frames.

**Heap**  
JVM имеет heap (кучу), которая используется всеми потоками виртуальной машины Java. 
Куча - это область данных времени выполнения, из которой выделяется память для всех экземпляров и 
массивов классов. Куча создается при запуске виртуальной машины. Хранилище для объектов восстанавливается 
автоматической системой управления данными (известной как сборщик мусора); объекты никогда не освобождаются явно.

**Method Area**
JVM имеет область методов, которая является общей для всех потоков. Она пул констант, данные полей и методов, 
а также код для методов и конструкторов. Хотя область метода является логически частью кучи, простые реализации могут 
не обрабатываться сборщиком мусора.

### Frames
Frame используется для хранения данных и частичных результатов, возврата значений для методов и отправки исключений. 
Новый frame создается каждый раз, когда вызывается метод. Frame уничтожается, когда завершается вызов метода, 
является ли это завершение нормальным или с исключением. Frames выделяются из стека потока, создающего frame.

Только один frame активен в любой точке данного потока управления - метода выполнения, и это frame называется 
текущим, а его метод известен как текущий метод. Frame перестает быть текущим, если его метод вызывает другой метод 
или если его метод завершается.

### Interpreter vs JIT Compiler
Интерпретатор интерпретирует байт-код быстро, но выполняется медленно. Недостаток интерпретатора заключается в том, 
что, когда один метод вызывается несколько раз, каждый раз требуется новая интерпретация.

JIT-компилятор устраняет недостатки интерпретатора. Механизм выполнения будет использовать помощь интерпретатора при 
преобразовании байт-кода, но когда он находит повторный код, он использует JIT-компилятор, который компилирует весь 
байт-код и изменяет его на собственный код. Этот нативный код будет использоваться непосредственно для повторных 
вызовов методов, которые улучшают производительность системы.