# Модель памяти Java
Каждый поток имеет свой стек, но все потоки имеют общую кучу. Схематично модель памяти Java выглядит так:
![img.png](png/java_memory_model.png)

В стеке каждого потока хранятся фреймы - данные вызовов каждого метода. Примитивные аргументы методов хранятся
непосредственно в стеке, объекты (и их поля) хранятся в куче. Даже если два потока одновременно выполняют
один и тот же метод, все равно каждый будет иметь свою копию фрейма с аргументами в стеке. 

![img.png](png/java_memory_model_example.png)

Современная аппаратная реализация памяти такая:

![img.png](png/pc_memory_model.png)

Каждый процессор может иметь несколько ядер, каждое ядро имеет свой регистр и кеш. Регистр и кеш - это память в 
процессоре для ускоренного доступа к данным. Стеки потоков и куча могут быть расположены во всех частях этой памяти. 
То есть что-то может храниться в регистре, что-то в кеше, что-то в ОЗУ. 

Отсюда могут возникнуть две проблемы:
1) Видимость изменений объектов
2) Состояние гонки

**Видимость объектов**  
Если два или более потока делят между собой объект без надлежащего использования volatile-объявления или синхронизации,
то изменения общего объекта, сделанные одним потоком, могут быть невидимы для других потоков.

Допустим, общий объект хранится в ОЗУ. Ядро_1 считывает общий объект себе в кеш или регистр и изменяет его. Пока кеш и
регистр ядра_1 не будет сброшен в ОЗУ, другие ядра не увидят изменений общего объекта. Таким образом каждый поток может
получить свою версию объекта. Для решения этой проблемы используют ключевое слово `volatile`, оно гарантирует, что такая
переменная будет считываться и зписываться непосредственно в ОЗУ. 

**Состояние гонки**  
Каждое ядро в своем кеше может выполнить изменение общего объекта и перезаписать чужое изменение при переносе общего
объекта в ОЗУ. Либо в случае неудачного временного координирования, такое может произойти даже с valotile переменной, 
если два ядра будут изменять объект одновременно.

Для решения этой проблемы использует синхронизированные блоки. Синхронизированные блоки также гарантируют, что все
переменные, к которым обращаются внутри синхронизированного блока, будут считаны из основной памяти, и когда поток 
выйдет из синхронизированного блока, все обновленные переменные будут снова сброшены в основную память, независимо от 
того, объявлена ли переменная как volatile или нет.

## Happens-before
Happens-before определяется как отношение между двумя действиями:

1) Пусть есть поток T1 и поток T2 (необязательно отличающийся от потока T1) и действия x и y, выполняемые в 
потоках T1 и T2 соответственно
2) Если x happens-before y, то во время выполнения y треду T2 будут видны все изменения, выполняемые в x тредом T1

Однако это не означает, что эти действия будут выполняться друг за другом. Дается гарантия только видимости изменений.
Если продолжать эту тему, последовательно будут выполняться лишь те действия, которые влияют на чтение данных друг друга.

Важно отметить, что отношение happens-before является транзитивным. То есть, если hb(x,y) и hb(y,z), то hb(x,z).

Примеры happens-before:
1) Два последовательных действия в одном треде
2) Освобождение монитора happens-before каждый последующий захват **того же самого** монитора
3) Запись в volatile переменную happens-before каждое последующее чтение той же самой переменной
4) Финальное действие в треде T1 happens-before любое действие в треде T2, которое обнаруживает, что тред T1 завершен
5) Действие запуска треда (Thread.start()) happens-before первое действие в этом треде
6) Если тред T1 прерывает тред T2, то интеррапт happens-before обнаружение интеррапта
7) Дефолтная инициализация (0, false или null) при создании переменной happens-before первое действие в каждом треде
8) 