# Java CORE
### Чем различаются JRE, JVM и JDK?
**JVM**, Java Virtual Machine (Виртуальная машина Java) — основная часть среды времени исполнения Java (JRE). 
Виртуальная машина Java исполняет байт-код Java, предварительно созданный из исходного текста Java-программы 
компилятором Java. JVM может также использоваться для выполнения программ, написанных на других языках программирования.

**JRE**, Java Runtime Environment (Среда времени выполнения Java) - минимально-необходимая реализация виртуальной 
машины для исполнения Java-приложений. Состоит из JVM и стандартного набора библиотек классов Java.

**JDK**, Java Development Kit (Комплект разработки на Java) - JRE и набор инструментов разработчика приложений на языке 
Java, включающий в себя компилятор Java, стандартные библиотеки классов Java, примеры, документацию, различные утилиты.

### Модификаторы доступа
**private**: члены класса доступны только внутри класса. Для обозначения используется служебное слово private.

**default**: видимость класса/членов класса только внутри пакета. Является модификатором доступа по умолчанию - 
специальное обозначение не требуется.

**protected**: члены класса доступны внутри пакета и в наследниках. Для обозначения используется служебное слово 
protected.

**public**: класс/члены класса доступны всем. Для обозначения используется служебное слово public.

Во время наследования возможно изменения модификаторов доступа в сторону большей видимости 
(для поддержания соответствия принципу подстановки Барбары Лисков).

### Каков порядок вызова конструкторов и блоков инициализации с учётом иерархии классов?

Parent static block(s) → Child static block(s) → Grandchild static block(s)

→ Parent non-static block(s) → Parent constructor →

→ Child non-static block(s) → Child constructor →

→ Grandchild non-static block(s) → Grandchild constructor

### Может ли статический метод быть переопределён или перегружен?
Перегружен - да. Всё работает точно так же, как и с обычными методами - 2 статических метода могут иметь одинаковое имя, 
если количество их параметров или типов различается.

Переопределён - нет. Выбор вызываемого статического метода происходит при раннем связывании (на этапе компиляции, а не 
выполнения) и выполняться всегда будет родительский метод, хотя синтаксически переопределение статического метода - 
это вполне корректная языковая конструкция.

В целом, к статическим полям и методам рекомендуется обращаться через имя класса, а не объект.

### Могут ли нестатические методы перегрузить статические?
Да. В итоге получится два разных метода. Статический будет принадлежать классу и будет доступен через его имя, а 
нестатический будет принадлежать конкретному объекту и доступен через вызов метода этого объекта.

### Можно ли объявить метод абстрактным и статическим одновременно?
Нет. Модификатор abstract говорит, что метод будет реализован в другом классе, а static наоборот указывает, что этот 
метод будет доступен по имени класса.

### Расскажите про вложенные классы. В каких случаях они применяются?
Класс называется вложенным (Nested class), если он определен внутри другого класса. Вложенный класс должен создаваться 
только для того, чтобы обслуживать обрамляющий его класс. Если вложенный класс оказывается полезен в каком-либо ином 
контексте, он должен стать классом верхнего уровня. Вложенные классы имеют доступ ко всем (в том числе приватным) полям 
и методам внешнего класса, но не наоборот. Из-за этого разрешения использование вложенных классов приводит к 
некоторому нарушению инкапсуляции.

### Что такое «анонимные классы»? Где они применяются?
Это вложенный локальный класс без имени, который разрешено декларировать в любом месте, разрешающем размещение выражений. 
Создание экземпляра анонимного класса происходит одновременно с его объявлением.

Анонимные классы обычно применяются для:
+ создания объекта функции (function object), например, реализация интерфейса Comparator;
+ создания объекта процесса (process object), такого как экземпляры классов Thread, Runnable и подобных;
+ в статическом методе генерации;

### Что такое Heap и Stack память в Java? Какая разница между ними?
**Heap** (куча) используется Java Runtime для выделения памяти под объекты и классы. Создание нового объекта также 
происходит в куче. Это же является областью работы сборщика мусора. Любой объект, созданный в куче, имеет глобальный 
доступ и на него могут ссылаться из любой части приложения.

Stack (стек) это область хранения данных также находящееся в общей оперативной памяти (RAM). Всякий раз, когда 
вызывается метод, в памяти стека создается новый блок (frame), который содержит примитивы и ссылки на другие объекты в методе. 
Как только метод заканчивает работу, блок также перестает использоваться, тем самым предоставляя доступ для следующего 
метода. Размер стековой памяти намного меньше объема памяти в куче. Стек в Java работает по схеме LIFO
(Последний-зашел-Первый-вышел)

### Верно ли утверждение, что примитивные типы данных всегда хранятся в стеке, а экземпляры ссылочных типов данных в куче?
Не совсем. Примитивное поле экземпляра класса хранится не в стеке, а в куче. 
Любой объект (всё, что явно или неявно создаётся при помощи оператора new) хранится в куче.

### Каким образом передаются переменные в методы, по значению или по ссылке?
В Java параметры всегда передаются только по значению, что определяется как «скопировать значение и передать копию». 
С примитивами это будет копия содержимого. Со ссылками - тоже копия содержимого, т.е. копия ссылки. 

При этом внутренние члены ссылочных типов через такую копию изменить возможно, а вот саму ссылку, 
указывающую на экземпляр - нет.

### Почему String неизменяемый и финализированный класс?
+ Пул строк возможен только потому, что строка неизменяемая, таким образом виртуальная машина сохраняет больше 
свободного места в Heap, поскольку разные строковые переменные указывают на одну и ту же переменную в пуле.
+ Неизменяемость позволяет избежать синхронизации

### Что делает метод intern() в классе String?.
Метод intern() используется для сохранения строки в пуле строк или получения ссылки, если такая строка уже 
находится в пуле.

### Какая основная разница между StringBuffer, StringBuilder?
Класс StringBuffer изменяемый - использовать StringBuffer следует тогда, когда необходимо часто модифицировать содержимое.

Класс StringBuilder был добавлен в Java 5 и он во всем идентичен классу StringBuffer за исключением того, что он не 
синхронизирован и поэтому его методы выполняются значительно быстрей.

### Процесс загрузки класса состоит из трех частей
+ **Loading** – на этой фазе происходит поиск и физическая загрузка файла класса в определенном источнике 
(в зависимости от загрузчика). Этот процесс определяет базовое представление класса в памяти. На этом этапе такие 
понятия как «методы», «поля» и т.д. пока не известны.
+ Linking – процесс, который может быть разбит на 3 части:
  + Bytecode verification – проверка байт-кода на соответствие требованиям, определенным в спецификации JVM. 
  + Class preparation – создание и инициализация необходимых структур, используемых для представления полей, методов, 
  реализованных интерфейсов и т.п., определенных в загружаемом классе.
  + Resolving – загрузка набора классов, на которые ссылается загружаемый класс.
+ Initialization – вызов статических блоков инициализации и присваивание полям класса значений по умолчанию.

Динамическая загрузка классов в Java имеет ряд особенностей:
+ отложенная (lazy) загрузка и связывание классов. Загрузка классов производится только при необходимости, 
что позволяет экономить ресурсы и распределять нагрузку.
+ проверка корректности загружаемого кода (type safeness). Все действия связанные с контролем использования типов
производятся только во время загрузки класса, позволяя избежать дополнительной нагрузки во время выполнения кода.

### equals и hashcode
Равные объекты должны возвращать одинаковые хэш коды. При переопределении equals() нужно обязательно 
переопределять и метод hashCode().

Классы и методы, которые не используют правила этого контракта могут работать некорректно. Так для HashMap это 
может привести к тому, что пара «ключ-значение», которая была в неё помещена при использовании нового экземпляра 
ключа не будет в ней найдена.

Реализация метода Object.hashCode() описана как native, т.е. определенной не с помощью Java кода и обычно возвращает 
адрес объекта в памяти

HashCode: 
+ если хэш коды разные, то и объекты гарантированно разные;
+ если хэш коды равны, то объекты не обязательно равны (могут быть разные).

### Есть ли какие-либо рекомендации о том, какие поля следует использовать при подсчете hashCode()?
Общий совет: выбирать поля, которые с большой долью вероятности будут различаться. Для этого необходимо 
использовать уникальные, лучше всего примитивные поля, например, такие как id, uuid. При этом нужно следовать 
правилу, если поля задействованы при вычислении hashCode(), то они должны быть задействованы и при выполнении equals().

### Иерархия исключений
Исключения делятся на несколько классов, но все они имеют общего предка — класс Throwable, потомками которого являются 
классы Exception и Error.

Ошибки (Errors) представляют собой более серьёзные проблемы, которые, согласно спецификации Java, не следует 
обрабатывать в собственной программе, поскольку они связаны с проблемами уровня JVM. Например, исключения 
такого рода возникают, если закончилась память доступная виртуальной машине.

Исключения (Exceptions) являются результатом проблем в программе, которые в принципе решаемы, предсказуемы и 
последствия которых возможно устранить внутри программы. Например, произошло деление целого числа на ноль.

В Java все исключения делятся на два типа:
+ **checked** (проверяемые исключения) должны обрабатываться блоком catch или описываться в заголовке метода. Наличие 
такого обработчика/модификатора в заголовке метода проверяется на этапе компиляции;
+ **unchecked** (непроверяемые исключения), к которым относятся ошибки Error и исключения времени выполнения, 
представленные классом RuntimeException и его наследниками, которые могут не обрабатываться блоком catch и не быть 
описанными в заголовке метода.

![throwable_hierarchy.png](png/throwable_hierarchy.png) 