# Базы данных

- [Что такое «реляционная модель данных»?](#что-такое-реляционная-модель-данных)
- [Какие бывают ключи](#какие-бывают-ключи)
- [Первичный ключ](#первичный-ключ)
- [Внешний ключ](#внешний-ключ)
- [Какие существуют нормальные формы](#какие-существуют-нормальные-формы)
- [Какие существуют типы связей в базе данных](#какие-существуют-типы-связей-в-базе-данных)
- [Индексы](#индексы)
- [ACID](#acid)
- [Проблемы изолированности транзакций](#проблемы-изолированности-транзакций)
- [Уровни изолированности транзакций](#уровни-изолированности-транзакций)

## Что такое «реляционная модель данных»?
Реляционные базы данных – старейший тип до сих пор широко используемых БД общего назначения. Данные и связи между 
данными организованы с помощью таблиц. Каждый столбец в таблице имеет имя и тип. Каждая строка представляет отдельную 
запись или элемент данных в таблице, который содержит значения для каждого из столбцов.

## Какие бывают ключи
**Простой ключ** состоит из одного атрибута (поля). **Составной** - из двух и более.

**Потенциальный ключ** - простой или составной ключ, который уникально идентифицирует каждую запись набора данных.

Из множества всех потенциальных ключей набора данных выбирают **первичный ключ**, все остальные ключи 
называют **альтернативными**.

## Первичный ключ
**Первичный ключ** (primary key) - аттрибут или набор аттрибутов, однозначно идентифицирующий запись из таблицы.

Критерии выбора:
1) Занимает меньше места и/или имеет меньшее число аттрибутов
2) Сохраняет уникальность со временем

## Внешний ключ
**Внешний ключ** (foreign key) — подмножество атрибутов некоторой таблицы A, значения которых должны совпадать со 
значениями некоторого потенциального ключа некоторой таблицы B.

## Какие существуют нормальные формы?
1) Значения всех атрибутов атомарны
2) Неключевые атрибуты зависят от ключа
3) Неключевые атрибуты не зависят друг от друга
4) Не содержатся независимые группы атрибутов, между которыми отношение «многие-ко-многим»
5) Соединения определяются потенциальным ключом.
6) База неприводима, то есть не может быть подвергнута дальнейшей декомпозиции без потерь

## Какие существуют типы связей в базе данных?
1) Один к одному - любому значению атрибута А соответствует только одно значение атрибута В, и наоборот.  
   Каждый университет гарантированно имеет 1-го ректора: 1 университет → 1 ректор.
2) Один ко многим - любому значению атрибута А соответствует 0, 1 или несколько значений атрибута В.  
   В каждом университете есть несколько факультетов: 1 университет → много факультетов.
3) Многие ко многим - любому значению атрибута А соответствует 0, 1 или несколько значений атрибута В, и 
любому значению атрибута В соответствует 0, 1 или несколько значение атрибута А.  
   1 профессор может преподавать на нескольких факультетах, в то же время на 1-ом факультете может преподавать 
несколько профессоров: Несколько профессоров ↔ Несколько факультетов.

## Индексы
**Индекс** (index) — объект базы данных, создаваемый с целью повышения производительности выборки данных.

Преимущества:
+ ускорение поиска и сортировки по определенному полю или набору полей.

Недостатки:
+ Тяжелее операции вставки
+ Занимает доп место (чем больше ключ, тем больше места)

Создание индекса - долгая и **блокирующая** операция. Есть неблокирующий вариант, но результат не гарантируется.

Индексы работают на основе деревьев, как правило, рядом с деревом из storage engine (b-tree или lsm-tree) есть 
еще одно дерево для индексов. Это дерево может хранить все необходимые поля внутри себя (тогда оно кластерное) и будет
быстрее, но занимать много места. А может хранить ссылки на данные в диске и тогда будет медленнее, но занимать меньше
места.

**Когда использовать индексы**:
+ SELECT преобладает над INSERT
+ Данные уникальны

**Когда не использовать индексы**:
+ Часто вставляют и редко читают
+ Данные не вариантивны (например значения да/нет)
+ Часто встречается NULL

**Типы индексов**:
По кластеризации:
+ Кластерный - помимо индексируемого поля и указателя с расположением данных в таблице, может содержать дополнительные 
поля. Если индекс полностью покрывает запрос, то обращения к самой таблице не будет.
+ Некластерный - содержит ток указатели, без дополнительных полей

По структуре:
+ B-деревья - на основе binary tree. Хорошо зарекомендовавший себя способ, используется в большинстве БД. Помимо самой 
индексации поддерживает индексацию по промежутку и не сортирует индексируемые данные
+ Хеши - по данным берется хеш значение, по посчитанному хешу можно найти указатель в таблице. Занимает меньше места, но 
не поддерживает поиск по промежутку и сортировку данных.

## ACID
1) **Атомарность** (atomicity) гарантирует, что никакая транзакция не будет зафиксирована в системе частично. Будут 
либо выполнены все её подоперации, либо не выполнено ни одной.
2) **Согласованность** (consistency). Транзакция после завершения оставляет БД в согласованном состоянии.
3) **Изолированность** (isolation). Во время выполнения транзакции параллельные транзакции не должны оказывать влияние 
на её результат.
4) **Долговечность** (durability). Независимо от проблем на нижних уровнях (к примеру, обесточивание системы или сбои 
в оборудовании) изменения, сделанные успешно завершённой транзакцией, должны остаться сохранёнными после возвращения 
системы в работу.

## Проблемы изолированности транзакций
При параллельном выполнении транзакций возможны следующие проблемы:
1) lost update — при одновременном изменении одного блока данных разными транзакциями одно из изменений теряется;
2) dirty read — чтение данных, добавленных транзакцией, которая впоследствии не подтвердится (откатится);
3) non-repeatable read — при повторном чтении в рамках одной транзакции ранее прочитанные данные оказываются изменёнными;
4) phantom reads - одна транзакция в ходе своего выполнения несколько раз выполняет один запрос. Другая транзакция 
в интервалах между этими запросами добавляет или удаляет записи, используемые в критериях выборки первой транзакции, 
и успешно заканчивается. В результате получится, что один и тот же запрос в первой транзакции дает разные множества 
записей.

## Уровни изолированности транзакций
В порядке увеличения изолированности транзакций и, соответственно, надёжности работы с данными:
1) read uncommitted - чтение незафиксированных изменений параллельных транзакций. Возможны потерянные изменения,
возможны неповторяемое чтение и фантомы.
2) read committed - чтение только зафиксированных изменений параллельных транзакций (**состояние базы запоминается перед 
выполнением команды**). Потерянные изменения и грязное чтение не допускается, возможны неповторяемое чтение и фантомы. 
Уровень защиты в PostgreSQL по умолчанию.
3) repeatable read — чтение изменений только своей транзакции (**состояние базы запоминается перед выполнением 
транзакции**). Потерянные изменения, грязное и неповторяемое чтение невозможны, возможны фантомы 
(потому что lock не работает на диапазон данных). В целом, в PostgreSQL самый оптимальный уровень защиты, есть read 
committed не подходит.
4) serializable — результат параллельного выполнения сериализуемой транзакции с другими транзакциями должен быть 
логически эквивалентен результату их какого-либо последовательного выполнения. Проблемы синхронизации не возникают.

### Репликации
Репликация - хранение копии одних и тех же данных на нескольких машинах. Существует несколько причин для репликации:
1) Ради хранения данных географически ближе к пользователю
2) Чтобы система могла работать при отказе некоторых систем
3) Для увеличения количества машин, способных принимать запросы на чтение

Основная сложность репликации в том, чтобы поддерживать репликации актуальными. Существуют при популярных алгоритма
решения этой задачи: репликация _с одним ведущим узлом_ (single-leader), _с несколькими ведущими_ (multi-leader) и
_без ведущего узла_ (leaderless).

Каждая операция записи в базу должна учитываться всеми репликами. Наиболее распространенное решение - репликация с
ведущим узлом (_leader-based replication_). Ее алгоритм:
1) Одна из реплик становится _ведущей_ (leader). Запись происходит только в ведущую реплику.
2) Другие реплики называются _ведомыми_ (followers). Ведущая реплика отправляет им все свои изменения и ведомые все
   повторяют.
3) Для чтения можно обратиться к ведущему или ведомому узлу.

Ведомая репликация называется синхронной, если ведущий узел ждет, пока репликация не повторит те же шаги. Если ожидания
не происходит, ведомая репликация не синхронна. Преимущества синхронности - всегда есть реплика, которая может
заменить лидера.

С введением реплик есть соблазн создать большое количество ведомых узлов и распределить по ним чтение. Это снизит
нагрузку с ведущего узла и позволить увеличить масштабируемость на чтение. Такой подход называется _масштабируемая
по чтению архитектура_ (read-scaling architecture). Однако этот подход работает только при асинхронной записи. При
синхронной выведение из строя одного узла может заблокировать запись. Соответственно, чем больше узлов, тем больше
шанс аварии.

Так же существует подход с несколькими ведущими узлами. Такая модель называется multi-leader replication или реплика
master-master.

Можно установить ведущий узел в каждом из ЦОДов. Внутри каждого ЦОДа есть ведущая и ведомые реплики. Ведущие двух ЦОДов
обмениваются информацией друг с другом. Вот плюсы такой схемы:
- Производительность. Все записи обрабатываются в локальных ЦОДах ближе к пользователю, субъективная задержка
  пользователя становится меньше.
- Устойчивость к перебоям ЦОДов. В случае выхода из строя какого-то ЦОДа, его работу может взять на себя другой рабочий.
- Устойчивость к перебоям сети. В случае проблем с сетью для региона, можно перенаправить трафик в ЦОД другого региона.

Однако есть свои минусы:
- Одни и те же данные могут одновременно редактироваться в двух различных ЦОДах. **Такие конфликты необходимо разрешать**.
- Может оказаться проблематичным использование триггеров, auto increment ключей и ограничений целостности. Поэтому
  репликация с несколькими ведущими узлами **считается опасной вещью, которой лучше избегать**.

Некоторые системы предлагают другой подход: в целом отказаться от ведущего узла, еще увеличив таким образом пропускную
способность.

Запись и чтение в такую базу производится _по кворуму_ сразу в несколько узлов. Общее правило таково:
при наличии N реплик операция записи считается успешной, если была подтверждена W узлами, причем мы должны опросить
как минимум R узлов для каждой операции чтения. Если W+R>N, то система считается надежной, так как из прочитанных R
реплик, хотя бы одна будет иметь обновленные данные. Для того чтобы понять, какие данные более новые, используется
версионность. Каждая запись имеет свою версию и та запись, что имеет бОльшую версию, считается самой последней и
корректной. Кворум так же может быть нестрогим (W+R<N), это еще больше увеличивает пропускную способность
(не нужно ждать ответ реплик), но уменьшает согласованность данных.

### Партиционирование
В случае больших объемов данных бывает необходимо разделить одно хранилище данных на несколько партиций (секций). Это
называют выполнением шардинга (sharding) данных. Основная цель партицирования данных - масштабируемость. Разные партиции
можно разместить на разных узлах кластера. Следовательно, большой объем данных можно разделить на несколько жестких дисков
и процессоров.

Горизонтальное партицирование (когда база режется построчно по **разным** машинам) == Шардирование.

Партиции обычно идут бок о бок с репликациями. То есть копии одной и той же партиции повторяются на нескольких узлах, на
узле может храниться больше одной партиции. Делается это все в целях отказоустойчивости. 

Способ разбиения на партиции:
1) По диапазону ключей - могут быть перегруженные партиции
2) По хешу - норм 

Со временем данных в БД становится больше или они могут неправильно распределиться по партициям. Для этой цели
необходима перебалансировка партиций. Существуют следующие методики:
1) Фиксированное количество партиций - кол-во партиций задается при первичной настройке БД, задают заранее большое число.
2) Динамическое кол-во партиций - когда партиция превышает по размеру определенный порог, она разбивается на две равные
партиции. И наоборот, если партиция слишком маленькая, она может объединиться с соседней.
3) Количество партиций пропорционально количеству узлов

Откуда клиент знает, к какому узлу и партиции ему надо подключиться, что получить данные? Учитывая, что узлы могут
падать и подниматься, а партиции ребалансироваться, это довольно острый вопрос. Необходим какой-то наблюдатель сверху,
который будет знать необходимые метаданные для маршрутизации.

На высоком уровне существует несколько вариантов решений:
1) Разрешить клиенту обращаться к любому узлу. Узел либо отдает искомые данные, либо перенаправляет в другой узел,
   который хранит искомые данные
2) Отправлять все поступающие запросы клиентов сначала в некий маршрутизатор (Zookeeper), который в свою очередь будет
   перенаправлять в необходимый узел
3) Клиент сам должен знать, в какой узел ему необходимо обращаться

### OLAP vs OLTP
Изначально БД проектировались для коммерческих целей. Для этих целей бд обычно находит пару строк в таблице, изменяет
их и записывает обратно. Сейчас основной паттерн работы с данными остался прежним. Такой паттерн называется
"обработка транзакций в реальном времени" (online transaction processing, **OLTP**).

Однако БД все шире используются для аналитической обработки данных. В этом случае бизнес аналитики выполняют
очень большие и трудоемкие запросы на всю базу, но запросы такие поступают не столь часто. Так же важна скорость
чтения, а не скорость вставки. Результаты своих запросов бизнес аналитики используют в отчетах для руководства
компании. Этот паттерн называется "аналитическая обработка данных в реальном времени" (online analytical
processing, **OLAP**).

Различия OLTP и OLAP:
1) Паттерн чтения - OLTP читает небольшое количество записей, OLAP агрегирует по большому количеству записей
2) Паттерн записи - OLTP произвольное записывание небольшого числа данных, OLTP групповой импорт данных из другой базы
3) Пользователи - OLTP конечные пользователи через веб приложение, OLTP штатные бизнес аналитики
4) Размер набора данных - OLTP от гигабайтов до терабайтов, OLAP от терабайтов до петабайтов

### Оптимизация SQL запросов
1) Select полей вместо Select *
2) Избегать Select DISTINCT
3) Использовать INNER JOIN вместо WHERE
4) Использовать WHERE вместо HAVING
5) Использовать % только в конце слова

Для дебага времени выполнения SQL запроса можно использовать `EXPLAIN ANALYZE` тулзу.

### Порядок выполнения SQL команд
1) FROM
2) ON
3) JOIN
4) where
5) GROUP BY
6) HAVING
7) SELECT
8) DISTINCT
9) ORDER BY
10) TOP

### Работа SQL оптимизатора
Работа оптимизатора:
1) Синтаксический разбор запроса. Построение дерева на основе запроса.
2) Дерево компилируется
3) Оптимизатор анализирует дерево с учетом существующих индексов и размеров таблиц. Решает какой будет порядок 
соединений таблиц, использования индексов и тд
4) Сохранение плана запроса и его выполнение

Этапы анализа оптимизатора:
1) Анализ запроса
2) Выбор индексов
3) Выбор порядка и метода соединений

# NoSQL
### Виды NoSQL
1) Ключ-значение - Redis
2) Колоночное - В каждом блоке хранятся данные только из одной колонки - Cassandra 
3) Документо-ориентированные - Mongo
4) Графовые - сетевая база данных, которая использует узлы и рёбра для отображения и хранения данных

### SQL vs NoSQL
1) Схема данных: SQL-база данных имеет строгую схему данных, которая определяет типы данных и связи между таблицами. 
В NoSQL-базах данных нет строгой схемы данных.
2) Масштабируемость: SQL-базы данных имеют ограничения на масштабируемость, из-за чего они могут быть неэффективны в 
обработке большого количества данных. NoSQL-базы данных обладают большой масштабируемостью, из-за чего они могут 
обрабатывать большие объёмы данных.
3) Гибкость запросов: SQL имеет очень мощный язык запросов, что делает его лучшим выбором для сложных запросов, 
связанных с большим количеством таблиц. С другой стороны, NoSQL имеет простой язык запросов, который хорошо подходит 
для запросов, связанных с большим количеством данных.
4) Скорость обработки: Несмотря на то, что SQL обычно работает медленнее, чем NoSQL, его мощный язык запросов позволяет 
быстро обрабатывать сложные запросы. С другой стороны, NoSQL работает очень быстро с неструктурированными данными в 
больших объёмах.

Особенности SQL:
- SQL-базы данных имеют жёстко определённый формат хранения данных, что делает их наиболее подходящим выбором для представления сложных связанных данных;
- SQL имеет мощный язык запросов, который позволяет обрабатывать сложные запросы;
- SQL-базы данных обычно требуют больших затрат на обслуживание и настройку.

Особенности NoSQL:
- NoSQL-базы данных хранят данные в форме документов, что делает их лучшим выбором для хранения неструктурированных данных, таких как данные о социальных сетях и блогах;
- NoSQL имеет простой язык запросов, который позволяет быстро обрабатывать запросы на огромные объёмы неструктурированных данных;
- NoSQL-базы данных позволяют быстрее масштабировать и расширять базу данных.

### Документоориетированная модель (MongoDB) vs реляционная
1) Док-ая модель ближе к ООП разработке. Зачастую данные хранятся в виде JSON, что ближе к объектам в коде. Реляционная
   модель в свою очередь требует ORM фреймворков, чтобы записи в таблице можно было представить в виде объектов.
2) Док-ая модель имеет лучше локальность данных (все данные в одном документе), но у них плохо со связями. В особенности
   с manu-to-one и many-to-many.
3) Док-ая модель более гибкая. Схема данных неявная и интерпритируется при чтении (scheme-on-read), в одной коллекции
   могут лежать данные разных форматов и узнаете вы это при чтении. Реляционная модель проверяет схему при записи
   и просто не даст записать неверные данные.

Основные доводы в пользу документной модели данных:
1) Гибкость схемы (Scheme on read)
2) Лучшая производительность в следствии локальности данных
3) Большая близость к применяемым структурам данных в коде

Доводы в пользу реляционной модели:
1) Лучшая поддержка соединений
2) Отсутствие гибкости схемы (Scheme on write)
3) Лучшая поддержка транзакций

### CAP теорема
В CAP говорится, что в распределенной системе возможно выбрать только 2 из 3-х свойств:
1) C (consistency) — согласованность. Каждое чтение даст вам самую последнюю запись.
2) A (availability) — доступность. Каждый узел (не упавший) всегда успешно выполняет запросы (на чтение и запись).
3) P (partition tolerance) — устойчивость к распределению. Даже если между некоторыми узлами нет связи, система продолжает работать.

Интересные детали:
1) Многие системы — просто P
2) В разработке обычно выбор между AP и CP
