# Микросервисы
### monolith vs microservices
Монолитная архитектура — это традиционная модель программного обеспечения, которая представляет собой единый модуль, 
работающий автономно и независимо от других приложений. Монолит полезен в стартапах, при небольшом бизнесе и для MVP 
продукта. Монолит легче написать, деплойнуть и поддерживать. Но монолит сложнее масштабировать и он хуже выдерживает 
большие нагрузки.

**Плюсы монолита**:
- Простой деплой - нужно развернуть один jarник
- Приложение легче разрабатывать, если оно не разрослось
- Производительный - одна кодовая база и нет вызова сторонних API

**Недостатки монолита**:
- Большой монолит сложно и долго разрабатывать и поддерживать
- Плохая масштабируемость
- Ненадежность - ошибка в одном модуле может положить весь монолит
- Препятствие для внедрения новых технологий из-за единой кодовой базы
- Малая гибкость 
- При внесении малых изменений нужно редеплоить весь монолит

Микросервисная архитектура (или просто «микросервисы») представляет собой метод организации архитектуры, основанный на 
ряде независимо развертываемых служб. У этих служб есть собственная бизнес-логика и база данных с конкретной целью. 
Обновление, тестирование, развертывание и масштабирование выполняются внутри каждой службы. Микросервисы разбивают 
крупные задачи, характерные для конкретного бизнеса, на несколько независимых баз кода.

**Преимущества микросервисов**:
- Гибкость - сервисы можно разрабатывать, деплоить, масштабировать независимо
- Непрерывное развертывание - деплоиться можно хоть каждый день
- Надежность - если что-то идет не так, падает один сервис, а не вся система

**Недостатки микросервисов**:
- Более сложная разработка, особенно если не следить за разрастанием кол-ва микросервисов 
- Рост расходов на инфраструктуру
- Командам нужен дополнительный уровень коммуникаций
- Взаимодействие между микросервисами

### Взаимодействие между микросервисами
Все взаимодействия можно разделить по группам. 

Первая группа, тип протокола:
1) Синхронный
2) Асинхронный

Вторая группа, кол-во получателей:
1) Один получатель. Каждый запрос должен обрабатываться только одним получателем или службой.
2) Несколько получателей. Каждый запрос может обрабатываться разным количеством получателей — от нуля до нескольких.

Технологии:
1) REST - один получатель, может быть синхронным и асинхронным. Использует HTTP протокол для отправки JSON/XML данных.
2) GraphQL - альтернатива REST. Тоже использует HTTP протокол, но позволяет определить клиенту, какие данные ему нужны.
3) Kafka/RabbitMQ - асинхронные, несколько получателей. Брокеры сообщений
4) gRPC - один получатель, может быть синхронным и асинхронным. Протокол для удаленного вызова метода. Производительный, 
кодирует данные, не человекочитаем. Удобен для быстрой отправки большого объема данных.

### Отказоустойчивость
Отказоустойчивость - свойство системы выполнять свои функции, даже после отказа одного или нескольких составных частей.

Проблемы:
1) Упавший сервис
2) Отказ БД
3) Отказавшие каналы связи
4) Вышедшие из строя внешние системы
5) Железо

Способы решения проблем:
1) **Код**
- Правильно обрабатывать упавшие вызовы сторонних сервисов (ретрай, игнорирование, ответ по умолчанию)
- Кеши
- Обрабатывать некорректный ввод
- Статический анализ кода
- Тестирование
2) **Архитектура**
- Изолировать функционал и уменьшать связность 
- Database per service
- Паттерны для работы с БД
- Правильный выбор канала взаимодействия между сервисами
3) **Инфраструктура**
- Оркестратор
- Использование Readyness и Liveness
- Разделение ресурсов контейнеров и лимиты для них
- Правильные DevOps релизы, бэкапы и восстановление
4) **Мониторинг**

