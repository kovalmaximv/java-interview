# ООП
### Назовите основные принципы ООП
Инкапсуляция - сокрытие реализации.  
Наследование - создание новой сущности на базе уже существующей.  
Полиморфизм - возможность иметь разные формы для одной и той же сущности.  
--  
Абстракция - набор общих характеристик.  
Посылка сообщений - форма связи, взаимодействия между сущностями.  
Переиспользование - все что перечислено выше работает на повторное использование кода.  

### Инкапсуляция
**Инкапсуляция** – это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и
скрыть детали реализации от пользователя, открыв только то, что необходимо при последующем использовании.

Пример инкапсуляци в реальной жизни - автомобили. Нам не обязательно знать, как устроен автомобиль внутри, чтобы уметь
им пользоваться.

### Наследование
**Наследование** – это свойство системы, позволяющее описать новый класс на основе уже существующего с частично
или полностью заимствующейся функциональностью.

Пример наследования - платформы при сборе тачек на заводах. Одна платформа - много машин.

### Полиморфизм
**Полиморфизм** – это свойство системы использовать объекты с одинаковым интерфейсом без информации о
типе и внутренней структуре объекта.

Пример - все машины имеют единый интерфейс управления. Водитель может сесть за любую машину и все они управляются
одинаково. Однако эти машины могут использоваться для разных целей: спортивные для скорости, джипы для проходимости, етс.

### Абстракция
**Абстрагирование** – это способ выделить набор общих характеристик объекта, исключая из рассмотрения частные и
незначимые. Соответственно, абстракция – это набор всех таких характеристик.

### Обмен сообщениями
Объекты взаимодействуют, посылая и получая сообщения. Сообщение — это запрос на выполнение действия, дополненный
набором аргументов, которые могут понадобиться при выполнении действия. В ООП посылка сообщения (вызов метода) —
это единственный путь передать управление объекту. Так же объекты, используя свои методы, могут и сами посылать
сообщения другим объектам. Обмен сообщениями реализуется с помощью динамических вызовов, что приводит к чрезвычайно
позднему связыванию (extreme late binding).

### Преимущества и недостатки ООП
Преимущества:
+ Объектная модель вполне естественна, поскольку в первую очередь ориентирована на человеческое восприятие мира,
  а не на компьютерную реализацию.
+ Данные и операции над ними образуют определенную сущность, и они не разносятся по всей программе, как нередко бывает
  в случае процедурного программирования, а описываются вместе. Локализация кода и данных улучшает наглядность и
  удобство сопровождения программного обеспечения.
+ Использование полиморфизма оказывается полезным при
    + Обработке разнородных структур данных. Программы могут работать, не различая вида объектов, что
      существенно упрощает код. Новые виды могут быть добавлены в любой момент.
    + Изменении поведения во время исполнения. На этапе исполнения один объект может быть заменен другим, что
      позволяет легко, без изменения кода, адаптировать алгоритм в зависимости от того, какой используется объект.
+ Повторное использование кода

Недостатки:
+ Проектирование классов порой нетривиальная задача.
+ Очень трудно проектировать класс, не имея возможности его "пощупать".
+ В сложных иерархиях классов поля и методы обычно наследуются с разных уровней.
+ Код для обработки сообщения иногда «размазан» по многим методам.
+ Излишняя универсальность. Часто содержится больше методов, чем это реально необходимо текущей программе.

### ООП и выражения «является» и «имеет»
«является» подразумевает наследование. «имеет» подразумевает ассоциацию (агрегацию или композицию).

### В чем разница между композицией и агрегацией?
Композиция и агрегация — частные случаи ассоциации «часть-целое».

Разница между композицией и агрегацией заключается в том, что в случае композиции целое явно контролирует время
жизни своей составной части (часть не существует без целого), а в случае агрегации целое хоть и содержит свою
составную часть, время их жизни не связано (например, составная часть передается через параметры конструктора).

### Что такое статическое и динамическое связывание?
Присоединение вызова метода к телу метода называется связыванием. Если связывание проводится компилятором
(компоновщиком) перед запуском программы, то оно называется статическим или ранним связыванием (early binding).

В свою очередь, позднее связывание (late binding) это связывание, проводимое непосредственно во время выполнения
программы, в зависимости от типа объекта. Позднее связывание также называют динамическим (dynamic). В языках,
реализующих позднее связывание, должен существовать механизм определения фактического типа объекта во время работы
программы, для вызова подходящего метода. Иначе говоря, компилятор не знает тип объекта, но механизм вызова
методов определяет его и вызывает соответствующее тело метода.

Для всех методов Java используется механизм позднего (динамического) связывания, если только метод не был
объявлен как final (приватные методы являются final по умолчанию).

# Проектирования

### SOLID
1) Single Responsibility - Модуль имеет только 1 причину для изменения
2) Open-Closed Principle - Модуль открыт для расширения и закрыт для изменений
3) Liskov Principle - Взаимозаменяемые части должны иметь общий контракт. По сути про интерфейсы
4) Interface Segregation Principle - Необходимо избегать от зависимостей, которые не используются
5) Dependency Inversion Principle - высокоуровневый код не должен зависеть от низкоуровневого кода.
   Зависимость направлена на абстракции, а не реализации

Стройте зависимости от абстракций, они стабильней.

### Что такое Dependency Injection?
**Dependency Injection** (внедрение зависимости) - паттерны и принципы разработки, которые позволяют писать
слабосвязный код. В полном соответствии с принципом единой обязанности объект отдаёт заботу о построении требуемых
ему зависимостей внешнему, специально предназначенному для этого общему механизму.

### DDD
Domain-Driven Design — подход к проектированию, в основе которого положено тесное сотрудничество клиента и разработчиков. 

Стоит понимать, что это не справочник с перечнем действий, а набор принципов разработки и проектирования. Вы вольны сами
выбирать, чего стоит придерживаться, а чего нет, в вашем конкретном случае. 

Весь бизнес делится на определенные **домены** (domain) - какая-то одна функция компании, выделенные в отдельный юнит, в 
который поместят команду разработки и бизнес эксперта данного домена. Обязательно тесное сотрудничество команды 
разработки с бизнес-экспертами. Вместе они вырабатывают **единый язык** (Ubiquitous Language) одинаково понятный всем 
участникам процесса. Очень сильно помогает в этом **ограниченный контекст** (Bounded Context) - это смысловая граница 
домена в которой возможно определить доменной единый язык. Такая граница не нагружает ненужным контекстом разработчиков
и экспертов (нужна знать контекст только своего домена) и позволяет не париться насчет того, что термины единого языка
могут повторяться в другом домене, главное чтобы они были уникальны в вашем ограниченном контексте.

Основная цель всего сие действия - проектирования высокоточной системы, которая будет выполнять потребности бизнеса. 
Не пишется код ради кода и не используются технологии ради технологий. Цель написанного кода - отражать поставленные 
бизнес цели. Иначе говоря, мы говорим о **стратегическом проектировании**.

Таким образом, основные столбы DDD:
- Единый язык
- Ограниченный контекст
- Стратегическое проектирование