# System design

- [monolith vs microservices](#monolith-vs-microservices)
- [Взаимодействие между микросервисами](#взаимодействие-между-микросервисами)
- [Отказоустойчивость](#отказоустойчивость)
- [Проблема распределенных транзакций](#проблема-распределенных-транзакций)
- [Когда выбирать Relational DB](#когда-выбирать-relational-db)
- [Когда выбирать Key-Value DB](#когда-выбирать-key-value-db)
- [Когда выбирать Column DB](#когда-выбирать-column-db)
- [Когда выбирать Document Oriented DB](#когда-выбирать-document-oriented-db)
- [Когда выбирать Graph DB](#когда-выбирать-graph-db)

## monolith vs microservices
Монолитная архитектура — это традиционная модель программного обеспечения, которая представляет собой единый модуль,
работающий автономно и независимо от других приложений. Монолит полезен в стартапах, при небольшом бизнесе и для MVP
продукта. Монолит легче написать, деплойнуть и поддерживать. Но монолит сложнее масштабировать и он хуже выдерживает
большие нагрузки.

**Плюсы монолита**:
- Простой деплой - нужно развернуть один jarник
- Приложение легче разрабатывать, если оно не разрослось
- Производительный - одна кодовая база и нет вызова сторонних API

**Недостатки монолита**:
- Большой монолит сложно и долго разрабатывать и поддерживать
- Плохая масштабируемость
- Ненадежность - ошибка в одном модуле может положить весь монолит
- Препятствие для внедрения новых технологий из-за единой кодовой базы
- Малая гибкость
- При внесении малых изменений нужно редеплоить весь монолит

Микросервисная архитектура (или просто «микросервисы») представляет собой метод организации архитектуры, основанный на
ряде независимо развертываемых служб. У этих служб есть собственная бизнес-логика и база данных с конкретной целью.
Обновление, тестирование, развертывание и масштабирование выполняются внутри каждой службы. Микросервисы разбивают
крупные задачи, характерные для конкретного бизнеса, на несколько независимых баз кода.

**Преимущества микросервисов**:
- Гибкость - сервисы можно разрабатывать, деплоить, масштабировать независимо
- Непрерывное развертывание - деплоиться можно хоть каждый день
- Надежность - если что-то идет не так, падает один сервис, а не вся система

**Недостатки микросервисов**:
- Более сложная разработка, особенно если не следить за разрастанием кол-ва микросервисов
- Рост расходов на инфраструктуру
- Командам нужен дополнительный уровень коммуникаций
- Взаимодействие между микросервисами

## Взаимодействие между микросервисами
Все взаимодействия можно разделить по группам.

Первая группа, тип протокола:
1) Синхронный
2) Асинхронный

Вторая группа, кол-во получателей:
1) Один получатель. Каждый запрос должен обрабатываться только одним получателем или службой.
2) Несколько получателей. Каждый запрос может обрабатываться разным количеством получателей — от нуля до нескольких.

Технологии:
1) REST - один получатель, может быть синхронным и асинхронным. Использует HTTP протокол для отправки JSON/XML данных.
2) GraphQL - альтернатива REST. Тоже использует HTTP протокол, но позволяет определить клиенту, какие данные ему нужны.
3) Kafka/RabbitMQ - асинхронные, несколько получателей. Брокеры сообщений
4) gRPC - один получатель, может быть синхронным и асинхронным. Протокол для удаленного вызова метода. Производительный,
   кодирует данные, не человекочитаем. Удобен для быстрой отправки большого объема данных.

## Отказоустойчивость
Отказоустойчивость - свойство системы выполнять свои функции, даже после отказа одного или нескольких составных частей.

Проблемы:
1) Упавший сервис
2) Отказ БД
3) Отказавшие каналы связи
4) Вышедшие из строя внешние системы
5) Железо

Способы решения проблем:
1) **Код**
- Правильно обрабатывать упавшие вызовы сторонних сервисов (ретрай, игнорирование, ответ по умолчанию)
- Кеши
- Обрабатывать некорректный ввод
- Статический анализ кода
- Тестирование
2) **Архитектура**
- Изолировать функционал и уменьшать связность
- Database per service
- Паттерны для работы с БД
- Правильный выбор канала взаимодействия между сервисами
3) **Инфраструктура**
- Оркестратор
- Использование Readyness и Liveness
- Разделение ресурсов контейнеров и лимиты для них
- Правильные DevOps релизы, бэкапы и восстановление
4) **Мониторинг**

## Проблема распределенных транзакций
Пути ее решения:
#### 2PC: two-phase commit

[2PC](DISTRIBUTED_PATTERNS.md#2pc)

У каждой транзакции есть выделенный координатор. Алгоритм работает в 2 фазы:
1) Запрос (request) - инициируется новая транзакция, для нее генерируется номер (id). Координатор спрашивает
каждого участника "готов ли ты быстро и гарантированно завершить эту транзакцию?". Если кто-нибудь ответил "нет",
то отменяем транзакцию. Если кто-то ответил "да", то при наступлении следующего шага он **обязан** закоммититься,
даже если упадет.
2) Завершение - координатор принимает решение о commit или rollback и записывает это решение в свою надежную
память, после чего рассылает всем решение. 

Плюсы:
- стандартное решение, существует много готовых инструментов
- строгая консистентность данных

Минусы:
- Точка отказа в виде менеджера транзакций
- Все БД должны поддерживать DTP XA стандарт
- Падение узла (любого) может стать болью 

#### Оркестрация SAGA

[SAGA](DISTRIBUTED_PATTERNS.md#saga)

Вводится сервис-оркестратор, который запускает транзакции в остальных сервисах. Если что-то идет не так, он запускает
компенсирующие транзакции в этих сервисах. Внутри сервиса оркестратора, как правило, есть БД для хранения статусов 
транзакций. Данный подход имеет конечную согласованность, поскольку между вызовами сервисов может пройти некоторое 
время. Сервисы участники должны предоставить эндпоинты для отката транзакций.

Плюсы:
- Хорошо подходит для сложных рабочих процессов с участием большого количества участников или новых участников, добавленных с течением времени
- Участникам Saga не нужно знать о командах для других участников. Четкое разделение задач упрощает бизнес-логику
- Нет необходимости в DTP XA стандарте
- У оркестратора всегда можно узнать состояние транзакции
- Удобно отслеживать флоу транзакции в одном месте (оркестраторе)

Минусы:
- Требуется наличие компенсирующий транзакций
- Требуется реализация оркестратора
- Конечная согласованность
- Добавляется точка отказа в виде оркестратора

#### Хореография SAGA

[SAGA](DISTRIBUTED_PATTERNS.md#saga)

В данной версии саги вместо оркестратора каждый сервис выполняет локальную транзакцию и пушит сообщение в очередь,
откуда это сообщение читает другой сервис и выполняет локальные транзакции у себя. Если где-то что-то идет не так,
пушится сообщения с призывом применить компенсирующую транзакцию (данное сообщение получают все участники процесса).

Плюсы:
- Хорошо подходит для простых рабочих процессов, требующих нескольких участников и не требующих логики координации
- Нет необходимости в DTP XA стандарте
- Нет единой точки отказа в виде оркестратора

Минусы:
- Требуется наличие компенсирующий транзакций
- Рабочий процесс может запутаться при добавлении новых шагов, так как сложно отследить, какие участники саги слушают какие команды
- Конечная согласованность
- Не получится узнать состояние транзакции

## Когда выбирать Relational DB
Postgres, MySQL  
**Плюсы**:
- Хорошо подходит для хранения связанных между собой данных с четкой структурой данных
- **Поддерживает ACID гарантии для транзакций**
- Благодаря нормализации можно добиться более надежной согласованности

**Минусы**:
- Сложнее масштабировать, чем NoSQL решения

## Когда выбирать Key-Value DB
Redis, Memcache  
**Плюсы**:
- Неструктурированные гибкие данные
- **Быстрая скорость чтения (кэш)**
- Хранение данных в ОЗУ

**Минусы**:
- Не подходят для данных со сложной структурой или связями между собой
- Не поддерживаются ACID гарантии
- Нет сжатия данных и индексации (помимо ключа) -> не подходит для хранения большого количества данных

## Когда выбирать Column DB
Cassandra, HBase  
**Плюсы**:
- **Поддерживает хранение большого количества данных (легко шардируется)**
- Данные хранятся денормализовано для более быстрых запросов

**Минусы**:
- Поиск только по primary и partition key. Не поддерживается фильтрация, сортировка, и тд по остальным полям
- Не поддерживаются ACID гарантии

## Когда выбирать Document Oriented DB
MongoDB, CouchDB. Философия в том, чтобы не хранить данные в разных таблицах, а хранить данные в одном JSON
(денормализация).  
**Плюсы**:
- Данные хранятся денормализовано (и более локально) для более быстрых запросов
- **Гибкая схема данных**
- Богатая поддержка индексов и сложных запросов
- Ближе к ООП разработке, поскольку данные уже хранятся как объекты

**Минусы**:
- Не подходит для хранения данных со сложными связями из-за слабой поддержки join
- Из-за денормализации плохая ссылочная целостность (потому что в каждом документе свой поддокумент, который нужно обновить)

## Когда выбирать Graph DB
GraphDB, ArangoDB  
**Плюсы**:
- Работают быстрее для тесно связанных данных

**Минусы**:
- Сложно горизонтально масштабироваться
- Не подходит для hard write задач