# Design

- [Назовите основные принципы ООП](#назовите-основные-принципы-ооп)
- [Преимущества и недостатки ООП](#преимущества-и-недостатки-ооп)
- [Что такое статическое и динамическое связывание](#что-такое-статическое-и-динамическое-связывание)
- [SOLID](#solid)
- [Что такое Dependency Injection](#что-такое-dependency-injection)
- [DDD](#ddd)
- [Распределенный кэш vs локальный кэш](#распределенный-кэш-vs-локальный-кэш)
- [Для чего может использоваться распределенный кэш](#для-чего-может-использоваться-распределенный-кэш)
- [Распределенный лок (на примере Redis и Redlock)](#распределенный-лок-на-примере-redis-и-redlock)
- [Методы вытеснения из кэша](#методы-вытеснения-из-кэша)

## Назовите основные принципы ООП
Инкапсуляция - сокрытие реализации.  
Наследование - создание новой сущности на базе уже существующей.  
Полиморфизм - возможность иметь разные формы для одной и той же сущности.  
--  
Абстракция - набор общих характеристик.  
Посылка сообщений - форма связи, взаимодействия между сущностями.  
Переиспользование - все что перечислено выше работает на повторное использование кода.  

#### Инкапсуляция
**Инкапсуляция** – это свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и
скрыть детали реализации от пользователя, открыв только то, что необходимо при последующем использовании.

Пример инкапсуляци в реальной жизни - автомобили. Нам не обязательно знать, как устроен автомобиль внутри, чтобы уметь
им пользоваться.

#### Наследование
**Наследование** – это свойство системы, позволяющее описать новый класс на основе уже существующего с частично
или полностью заимствующейся функциональностью.

Пример наследования - платформы при сборе тачек на заводах. Одна платформа - много машин.

#### Полиморфизм
**Полиморфизм** – это свойство системы использовать объекты с одинаковым интерфейсом без информации о
типе и внутренней структуре объекта.

Пример - все машины имеют единый интерфейс управления. Водитель может сесть за любую машину и все они управляются
одинаково. Однако эти машины могут использоваться для разных целей: спортивные для скорости, джипы для проходимости, етс.

#### Абстракция
**Абстрагирование** – это способ выделить набор общих характеристик объекта, исключая из рассмотрения частные и
незначимые. Соответственно, абстракция – это набор всех таких характеристик.

#### Обмен сообщениями
Объекты взаимодействуют, посылая и получая сообщения. Сообщение — это запрос на выполнение действия, дополненный
набором аргументов, которые могут понадобиться при выполнении действия. В ООП посылка сообщения (вызов метода) —
это единственный путь передать управление объекту. Так же объекты, используя свои методы, могут и сами посылать
сообщения другим объектам. Обмен сообщениями реализуется с помощью динамических вызовов, что приводит к чрезвычайно
позднему связыванию (extreme late binding).

## Преимущества и недостатки ООП
Преимущества:
+ Объектная модель вполне естественна, поскольку в первую очередь ориентирована на человеческое восприятие мира,
  а не на компьютерную реализацию.
+ Данные и операции над ними образуют определенную сущность, и они не разносятся по всей программе, как нередко бывает
  в случае процедурного программирования, а описываются вместе. Локализация кода и данных улучшает наглядность и
  удобство сопровождения программного обеспечения.
+ Использование полиморфизма оказывается полезным при
    + Обработке разнородных структур данных. Программы могут работать, не различая вида объектов, что
      существенно упрощает код. Новые виды могут быть добавлены в любой момент.
    + Изменение поведения во время исполнения. На этапе исполнения один объект может быть заменен другим, что
      позволяет легко, без изменения кода, адаптировать алгоритм в зависимости от того, какой используется объект.
+ Повторное использование кода

Недостатки:
+ Проектирование классов порой нетривиальная задача.
+ Очень трудно проектировать класс, не имея возможности его "пощупать".
+ В сложных иерархиях классов поля и методы обычно наследуются с разных уровней.
+ Код для обработки сообщения иногда «размазан» по многим методам.
+ Излишняя универсальность. Часто содержится больше методов, чем это реально необходимо текущей программе.

## Что такое статическое и динамическое связывание?
Присоединение вызова метода к телу метода называется связыванием. Если связывание проводится компилятором
(компоновщиком) перед запуском программы, то оно называется статическим или ранним связыванием (early binding).

В свою очередь, позднее связывание (late binding) это связывание, проводимое непосредственно во время выполнения
программы, в зависимости от типа объекта. Позднее связывание также называют динамическим (dynamic). В языках,
реализующих позднее связывание, должен существовать механизм определения фактического типа объекта во время работы
программы, для вызова подходящего метода. Иначе говоря, компилятор не знает тип объекта, но механизм вызова
методов определяет его и вызывает соответствующее тело метода.

Для всех методов Java используется механизм позднего (динамического) связывания, если только метод не был
объявлен как final (приватные методы являются final по умолчанию).

## SOLID
1) Single Responsibility - Модуль имеет только 1 причину для изменения
2) Open-Closed Principle - Модуль открыт для расширения и закрыт для изменений
3) Liskov Principle - Взаимозаменяемые части должны иметь общий контракт. По сути про интерфейсы
4) Interface Segregation Principle - Необходимо избегать от зависимостей, которые не используются
5) Dependency Inversion Principle - высокоуровневый код не должен зависеть от низкоуровневого кода.
   Зависимость направлена на абстракции, а не реализации

Стройте зависимости от абстракций, они стабильней.

## Что такое Dependency Injection?
**Dependency Injection** (внедрение зависимости) - паттерны и принципы разработки, которые позволяют писать
слабосвязный код. В полном соответствии с принципом единой обязанности объект отдаёт заботу о построении требуемых
ему зависимостей внешнему, специально предназначенному для этого общему механизму.

## DDD
Domain-Driven Design — подход к проектированию, в основе которого положено тесное сотрудничество клиента и разработчиков. 

Стоит понимать, что это не справочник с перечнем действий, а набор принципов разработки и проектирования. Вы вольны сами
выбирать, чего стоит придерживаться, а чего нет, в вашем конкретном случае. 

Весь бизнес делится на определенные **домены** (domain) - какая-то одна функция компании, выделенные в отдельный юнит, в 
который поместят команду разработки и бизнес эксперта данного домена. Обязательно тесное сотрудничество команды 
разработки с бизнес-экспертами. Вместе они вырабатывают **единый язык** (Ubiquitous Language) одинаково понятный всем 
участникам процесса. Очень сильно помогает в этом **ограниченный контекст** (Bounded Context) - это смысловая граница 
домена в которой возможно определить доменной единый язык. Такая граница не нагружает ненужным контекстом разработчиков
и экспертов (нужно знать контекст только своего домена) и позволяет не париться насчет того, что термины единого языка
могут повторяться в другом домене, главное чтобы они были уникальны в вашем ограниченном контексте.

Основная цель всего сие действия - проектирования высокоточной системы, которая будет выполнять потребности бизнеса. 
Не пишется код ради кода и не используются технологии ради технологий. Цель написанного кода - отражать поставленные 
бизнес цели. Иначе говоря, мы говорим о **стратегическом проектировании**.

Таким образом, основные столбы DDD:
- Единый язык
- Ограниченный контекст
- Стратегическое проектирование

**Связь между DDD и микросервисной архитектурой**. Как правило, при реализации микросервисной архитектуры, это идет 
рука об руку с использованием DDD подхода. Просто эти две технологии лежат в разной плоскости:
1) DDD - более верхнеуровная стратегия моделирования системы на основе бизнесовых доменов и используя единое с бизнесом
понимание системы, что позволяет более эффективно развивать строить систему
2) микросервисы - архитектура программного обеспечения, призванная упростить разработку, отладку, деплой и 
поддерживание системы.

## Распределенный кэш vs локальный кэш
- Кэш в памяти (In-Memory Cache) используется для случаев, когда вам достаточно реализовать кэш в рамках одного процесса. 
Когда процесс умирает, кэш умирает вместе с ним. Если вы выполняете один и тот же процесс на нескольких серверах, у вас 
будет отдельный кэш для каждого сервера.
- Постоянный локальный кэш (Persistent in-process Cache) — это когда вы создаете резервную копию кэша вне памяти 
процесса. Он может располагаться в файле или в базе данных. Он сложнее кэша в памяти, но если ваш процесс 
перезапускается, кэш не сбрасывается. Лучше всего подходит для случаев, когда получение кэшируемого элемента затратно, 
а ваш процесс имеет обыкновение часто перезапускаться.
- Распределенный кэш (Distributed Cache) — это когда вам нужен общий кэш для нескольких машин. Обычно это несколько 
серверов. Распределенный кэш хранится во внешней службе. Это означает, что если один сервер сохранил элемент кэша, 
другие серверы также могут его использовать. Такие сервисы, как Redis, отлично для этого подходят.

## Для чего может использоваться распределенный кэш?
Показания по использованию кэша в целом:
1) Нагрузка смещена в сторону чтения, а не записи
2) В модели данных можно выделить ключ
3) Пользователи используют много совместных одинаковых данных (например каталог продуктов, справочник, итд)

Показания по использованию распределенного кэша:
1) Большая архитектура с большим количеством сервисов на разных машинах
2) Снять нагрузку с постоянного хранилища и для некоторых данных обращаться в кэш. Если данных в кэше нет, тогда идти в БД.

## Распределенный лок (на примере Redis и Redlock)
Распределенный лок - мьютекс в мире распределенного кэша (аналог synchronized в Java). Redlock гарантирует следующее:
1) В каждый момент времени только один клиент может удерживать блок и обращаться к данным
2) Лок можно захватить если предыдущий держатель лока крашнулся или упал (но не сразу, а eventually)
3) До тех пор, пока большинство нод Redis в строю, возможно захватить лок

Алгоритм работы для одного инстанса Redis:
1) Запись `SET resource_name my_random_value NX PX transaction_max_time`
2) Удаление записи (этим же клиентом) после завершения транзакции, иначе удаление записи если прошло `transaction_max_time`

Алгоритм работы (на примере N реплик):
1) Клиент запоминает current время в миллисекундах
2) Клиент пытается захватить лок во всех N репликах (используется один и тот же ключ и значение для лока). Если реплика
недоступна, клиент пытается захватить лок в следующем как можно скорее. Во время этого шага сверяется, что время между 
захватами лока не превышает какого-то определенного малого значения. Это нужно, чтобы 1 клиент не пытался долго 
захватывать локи.
3) Если клиенту удалось захватить лок на большинстве реплик (N/2 + 1) и время захвата меньше, чем доступное время 
удержание замка, то захват лока считается успешным.
4) Клиент может выполнять необходимую работу, у него осталось доступное время для удержания замка - (минус) время 
которое было потрачено на захват замка
5) Если захватить лок на большинстве реплик не удалось, то клиент снимает блокировку с реплик, где это сделать удалось и
пробует позже еще раз.

## Методы вытеснения из кэша
Основные методы вытеснения из кэша:
- **LRU** — не использованный дольше всех вылетает из кеша.
- **MRU** — последний использованный вылетает из кеша (специфичный кейс, бережем старье).
- **LFU** — реже всего использованный вылетает из кеша.

Каждый из методов можно реализовать с помощью hashmap и очереди с приоритетом. В мапе будут храниться сами элементы кеша, 
а в очереди с приоритетами будут храниться ключи в порядке их использования. В самом начале (а значит самый маленький),
ключ, который использовался очень давно, в самом конце ключ использовался совсем недавно.